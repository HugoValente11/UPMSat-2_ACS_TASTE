#!/usr/bin/python3
# -*- coding: utf-8 -*-

# TASTE-CREATE-GIT-IGNORE
#
# Purpose:
#    This script creates a .gitignore file given a set of TASTE functions passed
#    as command line arguments. If the file exist the contents are NOT erased
#    but appended.
#
# Considerations:
#     This script SHALL be invoked in the TASTE project root since it depends on
#     the location of the work directory.
#
#     Although, the entry point is located in the bottom af all functions. This
#     script is intended to be read from top to bottom.

#                 Copyright (C) 2022 STRAST-UPM research group
#           This work was developed in the context of the AURORA project
#
# - Author:  Angel Perez Munoz <groverperezm-2000@hotmail.com>
# - Company: STRAST research group from UPM.

import os
import sys

from typing import List

##  Globals  ###################################################################

TASTE_SUPPORTED_LANGS = [
    "C", "CPP", "Ada", "SDL",
    "Simulink", "QGenC", "QGenAda",
    "GUI", "Blackbox_Device"
]

MY_NAME   = sys.argv[0]

CWD       = os.getcwd()

GI_FOLDER = os.path.join(CWD, "work")

DEBUG     = "-dbg" in sys.argv

PRELUDE = """\
################################################################################
#                               G I T I G N O R E                              #
#                                                                              #
#         This file was autogenerated by TASTE, please do not edit it          #
################################################################################

# qtcreator generated files:
#../*.pro.user*
#../*.creator.user*

# Project files (AADL) autogenerated by TASTE
#../InterfaceView.aadl
#../DataView.aadl

# Ignore everything in this (work) directory except the gitignore
*
!.gitignore

"""

##  Functions  #################################################################

# Main
######

def main():
    taste_fns = console()
    print_debug("Processing functions: " + ', '.join(taste_fns))

    with open(os.path.join(GI_FOLDER, ".gitignore"), "w+") as f:
        rc = fill_gitignore(f, taste_fns)
        return rc

# Console
#########

def console() -> List[str]:
    """
    Returns:
       A list with the names of all the TASTE functions passed as command line
       arguments.
    """
    if "-h" in sys.argv:
        usage()
        sys.exit(0)

    if DEBUG:
        sys.argv.remove("-dbg")

    n_of_funcs = len(sys.argv) - 1
    if n_of_funcs <= 0:
        print("Error: Illegal number of arguments")
        usage()
        sys.exit(1)

    taste_fns = [os.path.basename(a.strip("/"))for a in sys.argv[1:]]
    return taste_fns

def usage():
    print(f"""\
Usage: {MY_NAME} [-dbg] <FUNCTIONS>
Where:
    - <FUNCTIONS> is the space separated list of TASTE functions
    - [-dbg] is an optional flag to run in debug mode and print verbose messages""")


# fill_gitignore
################

def fill_gitignore(f, taste_fns : List[str]) -> int:
    f.write(PRELUDE)
    f.write(''.join([lines_for_fn(fn) for fn in taste_fns]))
    f.write("# EOF")

    return 0


# lines_for_fn
##############

def lines_for_fn(fn_name : str) -> str:
    """Creates the list of files to be excluded for the given TASTE function

    Args:
        fn_name: Name of the function to be processed.

    Returns:
        The lines (a string) that should be added to the gitignore in order to
        include only the code written by the user for the function fn_name.
    """

    # Ignore base dir from fn_name:
    lines = f"""\
# Ignore everything except hand written files from {fn_name}:
!{fn_name}
{fn_name}/*
"""

    # Do not ignore soft links:
    for lang in TASTE_SUPPORTED_LANGS:
        lines = lines + f"!{fn_name}/{lang}" + os.linesep

    # Ignore autogenerated files but not user files:
    lines = lines + f"""\
!{fn_name}/implem
{fn_name}/implem/*


{lines_to_exclude_impl(fn_name)}
"""

    return lines

# lines_to_exclude_impl
#######################

def lines_to_exclude_impl(fn_name):
    print_debug("+ " + fn_name)
    lines = ""
    for implem_name in implementations_from(fn_name):
        print_debug("  - " + implem_name)
        lines = lines + f"""\
#   `-> implementation: {implem_name}:
!{fn_name}/implem/{implem_name}
{fn_name}/implem/{implem_name}/*
"""
        for lang in languages_from(fn_name, implem_name):
            lines = lines + lines_to_exclude_lang(fn_name, implem_name, lang)

    return lines

def implementations_from(fn_name : str) -> List[str]:
    implem_folder_name = os.path.join(GI_FOLDER, fn_name, "implem")

    if os.path.exists(implem_folder_name):
        implementations = dirs_inside(implem_folder_name)
        return implementations
    else:
        return [""]

def languages_from(fn_name : str, implem_name: str) -> List[str]:
    implem_folder_name = os.path.join(GI_FOLDER, fn_name, "implem", implem_name)
    langs = [
        lang
        for lang in dirs_inside(implem_folder_name)
        if lang in TASTE_SUPPORTED_LANGS
    ]

    return langs


# lines_to_exclude_lang
#######################

def lines_to_exclude_lang(fn_name, implem_name, lang):
    print_debug("    Â· " + lang)
    return f"""\
!{fn_name}/implem/{implem_name}/{lang}
{fn_name}/implem/{implem_name}/{lang}/*
!{fn_name}/implem/{implem_name}/{lang}/src
{fn_name}/implem/{implem_name}/{lang}/src/*
!{fn_name}/implem/{implem_name}/{lang}/src/{user_file_from(fn_name, lang)}
"""

def user_file_from(fn_name : str, lang : str) -> str:
    if lang == "C" or lang == "Blackbox_C":
        return f"{fn_name.lower()}.c"
    if lang == "Ada":
        return f"{fn_name.lower()}.adb"
    if lang == "CPP":
        return f"{fn_name.lower()}.cc"
    if lang == "SDL":
        return f"{fn_name.lower()}.pr"
    if lang == "GUI":
        return "UserWidgets.py"
    if lang == "QGenC" or lang == "QGenAda" or lang == "Simulink":
        return "*"
    else:
        return ""

# print_debug
#############

def print_debug(msg):
    if DEBUG:
        print("Debug: ", msg)


# dirs_from
###########

def dirs_inside(this_dir : str) -> List[str]:
    dirs = [
        dir
        for dir in os.listdir(this_dir)
        if os.path.isdir(os.path.join(this_dir, dir))
    ]

    return dirs


##  Entry Point  ###############################################################

if __name__ == "__main__":
    rc = main()
    sys.exit(rc)


"""
Acronyms:
=========

- fn   : Function
- gi   : git ignore
- lang : Language

Notes:
======

Suppose you have a TASTE project named TP and it contains a function name TF_1.
Now, let's assume that TF_1 has n implementations, in all the possible modelling
and programming languages.

In the latest version of taste (v10 with KAZOO) the project TP would have the
following structure:

TP
`-- Makefile
    `-- work
        `-- TF_1
            |-- CPP  # Soft link to the current CPP implementation
            |-- Ada  # Soft link to the current Ada implementation
            `-- implem
                |-- <Implementation name 1>
                |   |-- C
                |   |-- Ada
                |   |-- ...
                |   `-- GUI
                |-- <Implementation name 2>
                |-- ...
                `-- <Implementation name n>

*However*, when there is only one implementation for a TASTE function, the implem
folder is omitted. E.g: we have a QGenC function named MyQGenFunc, then the tree
for that function would be:

    TP
    `-- Makefile
        `-- work
            `-- MyQgenFunc
                `-- QGenC   # NOTE: This is NOT a soft-link
                    `-- src
                        |-- # Filled with autogenerated files and
                        `-- # Simulink models edited by the user.

"""
