#!/usr/bin/python3
# -*- coding: utf-8 -*-

#                T A S T E - C R E A T E - G I T - I G N O R E
#
# Purpose:
#    This script creates a .gitignore file given a set of TASTE functions passed
#    as command line arguments. If the file exist the contents are NOT erased
#    unless specified by the user.
#
# Considerations:
#    This script SHOULD be invoked in the TASTE project root since it depends on
#    the location of the work directory. However, you can specify the TASTE root
#    project location with the -r flag.
#
#    Although, the entry point is located in the bottom af all functions. This
#    script is intended to be read from top to bottom.
#
#               Copyright (C) 2022 STRAST-UPM research group
#        This work was developed in the context of the AURORA project
#
# - Author:  Ángel Pérez Muñoz <groverperezm-2000@hotmail.com>
# - Company: STRAST research group from UPM.

from curses import tparm
import os
import sys

from typing import List

##  Globals  ###################################################################

TASTE_SUPPORTED_LANGS = [
    "C",
    "CPP",
    "Ada",
    "SDL",
    "Simulink",
    "QGenC",
    "QGenAda",
    "GUI",
    "Blackbox_Device"
]


# Console Class #
# ============= #

class Console:
    """
    This module (static class) gathers the options introduce by the user in the
    console
    """

    # Initialize static variables to default:

    my_name = os.path.basename(sys.argv[0])

    flags = {
        "DEBUG_SET" : False,
        "FORCE_SET" : False,
    }

    tp_dir = os.getcwd()
    gi_dir = os.path.join(tp_dir, "work")

    taste_fns = [""]

    # initialize
    ############

    @staticmethod
    def initialize() -> None:
        """
        This procedure MUST be invoked before any other operation, since it
        initializes the static variables regarding the user's command line
        options and flags.
        """

        if "-h" in sys.argv:
            Console.print_usage()
            sys.exit(0)

        Console.flags["DEBUG_SET"] = "-dbg" in sys.argv
        if Console.flags["DEBUG_SET"]:
            sys.argv.remove("-dbg")

        Console.flags["FORCE_SET"] = "-f"   in sys.argv
        if Console.flags["FORCE_SET"]:
            sys.argv.remove("-f")

        if "-r" in sys.argv:
            idx = sys.argv.index("-r")
            Console.tp_dir = sys.argv[idx + 1]
            Console.gi_dir = os.path.join(Console.tp_dir, "work")
            del sys.argv[idx]
            del sys.argv[idx]

        there_are_no_fns = (len(sys.argv) - 1) == 0
        if there_are_no_fns:
            print("Info: You will ignore everything inside the work directory")

        Console.taste_fns = [os.path.basename(a.strip("/"))for a in sys.argv[1:]]

    # print_usage
    #############

    @staticmethod
    def print_usage() -> None:
        print(f"""\
Usage: {Console.my_name} [-dbg] [-f] [-r ROOT] <FUNCTIONS>
    - <FUNCTIONS>   space separated list of TASTE functions to be ignored
    - [-dbg]        optional flag to run in debug mode and print verbose messages
    - [-f]          if a gitignore file exists, override it.
    - [-r ROOT]     specify the TASTE root project location""")

##  Functions  #################################################################

# Main
######

def main():

    Console.initialize()

    taste_fns = Console.taste_fns
    print_debug("Processing functions: " + ', '.join(taste_fns))

    try:
        mode = "w+" if Console.flags["FORCE_SET"] else "x"
        with open(os.path.join(Console.gi_dir, ".gitignore"), mode) as gi_fd:
            return fill_gitignore(gi_fd, taste_fns)
    except FileExistsError as existing:
        print(f"Error: The {existing.filename} file exists, use the -f option to overwrite it!")
    except FileNotFoundError as not_found:
        print(f"Error: The file {not_found.filename} already exist")

    Console.print_usage()
    return 1

# fill_gitignore
################

def fill_gitignore(gi_fd, taste_fns : List[str]) -> int:
    gi_fd.write("""\
################################################################################
#                              G I T I G N O R E                               #
#                                                                              #
#         This file was autogenerated by TASTE, please do not edit it          #
################################################################################

# Ignore everything in this (work) directory except the gitignore
*
!.gitignore

""")
    gi_fd.write(''.join([lines_for_fn(fn) for fn in taste_fns]))
    gi_fd.write("# EOF\n")

    return 0


# lines_for_fn
##############

def lines_for_fn(fn_name : str) -> str:
    """Creates the list of files to be excluded for the given TASTE function

    Returns:
        The lines (a string) that should be added to the gitignore in order to
        include only the code written by the user for the function fn_name.
    """
    print_debug("+ " + fn_name)

    # Ignore base dir from fn_name:
    lines = f"""\
# Ignore everything except hand written files from the {fn_name} TASTE function:
!{fn_name}
{fn_name}/*
"""

    # Ignore autogenerated files but not hand-written files:
    # See Notes (at the end of the script) about the folder structure.
    implems_for_fn = implementations_from(fn_name)
    only_one_implementation = len(implems_for_fn) == 0
    if only_one_implementation:
        lines = lines + lines_to_exclude_one_implem(fn_name)
    else:
        lines = lines + lines_to_exclude_various_implem(fn_name, implems_for_fn)

    return lines

# implementations_from
######################
def implementations_from(fn_name : str) -> List:
    implem_folder_name = os.path.join(Console.gi_dir, fn_name, "implem")

    if os.path.exists(implem_folder_name):
        implementations = dirs_inside(implem_folder_name)
        return implementations

    return []

# lines_to_exclude_impl
#######################

# executed when there are no implementations in the implem folder:
def lines_to_exclude_one_implem(fn_name) -> str:
    lang = languages_from(os.path.join(Console.gi_dir, fn_name))[0]
    print_debug("  - " + lang)
    return f"""\
!{fn_name}/{lang}
{fn_name}/{lang}/*
!{fn_name}/{lang}/src
{fn_name}/{lang}/src/*
!{fn_name}/{lang}/src/{user_file_from(fn_name, lang)}
"""

# executed when there are implementations in the implem folder:
def lines_to_exclude_various_implem(fn_name, implems : List[str]) -> List[str]:
    lines = ""

    # Do not ignore soft links:
    for lang in TASTE_SUPPORTED_LANGS:
        lines = lines + f"!{fn_name}/{lang}" + os.linesep

    # Ignore impl folder and its autogenerated contents:
    lines = lines + f"""\
!{fn_name}/implem
{fn_name}/implem/*
"""
    for implem_name in implems:
        print_debug("  - " + implem_name)
        lines = lines + f"""\
#   `-> implementation: {implem_name}:
!{fn_name}/implem/{implem_name}
{fn_name}/implem/{implem_name}/*
"""
        for lang in languages_from(os.path.join(Console.gi_dir, fn_name,"implem", implem_name)):
            lines = lines + lines_to_exclude_lang(fn_name, implem_name, lang)

    return lines

# languages_from
################
def languages_from(path : str) -> List[str]:
    implem_folder_name = path
    langs = [
        lang
        for lang in dirs_inside(implem_folder_name)
        if lang in TASTE_SUPPORTED_LANGS
    ]

    return langs


# lines_to_exclude_lang
#######################

def lines_to_exclude_lang(fn_name, implem_name, lang):
    print_debug("    · " + lang)
    return f"""\
!{fn_name}/implem/{implem_name}/{lang}
{fn_name}/implem/{implem_name}/{lang}/*
!{fn_name}/implem/{implem_name}/{lang}/src
{fn_name}/implem/{implem_name}/{lang}/src/*
!{fn_name}/implem/{implem_name}/{lang}/src/{user_file_from(fn_name, lang)}
"""

# user_file_from
################

def user_file_from(fn_name : str, lang : str) -> str:
    user_file = ""
    if lang in ("C", "Blackbox_C"):
        user_file = f"{fn_name.lower()}.c"
    if lang == "Ada":
        user_file = f"{fn_name.lower()}.adb"
    if lang == "CPP":
        user_file = f"{fn_name.lower()}.cc"
    if lang == "SDL":
        user_file = f"{fn_name.lower()}.pr"
    if lang == "GUI":
        user_file = "UserWidgets.py"
    if lang in ("QGenC", "QGenAda", "Simulink"):
        user_file = "*"

    return user_file

# print_debug
#############

def print_debug(msg):
    if Console.flags["DEBUG_SET"]:
        print("Debug: ", msg)

# dirs_inside
#############

def dirs_inside(this_dir : str) -> List[str]:
    dirs = [
        dir
        for dir in os.listdir(this_dir)
        if os.path.isdir(os.path.join(this_dir, dir))
    ]

    return dirs


##  Entry Point  ###############################################################

if __name__ == "__main__":
    sys.exit(main())


"""
Acronyms:
=========

- fn     : Function
- gi     : git ignore
- lang   : Language
- implem : Implementation

Notes:
======

Suppose you have a TASTE project named TP and it contains a function name TF_1.
Now, let's assume that TF_1 has n implementations, in all the possible modelling
and programming languages.

In the latest version of taste (v10 with KAZOO) the project TP would have the
following structure:

    TP
    |-- Makefile
    `-- work
        `-- TF_1
            |-- CPP  # Soft link to the current CPP implementation
            |-- Ada  # Soft link to the current Ada implementation
            `-- implem
                |-- <Implementation name 1>
                |   |-- C
                |   |-- Ada
                |   |-- ...
                |   `-- GUI
                |-- <Implementation name 2>
                |-- ...
                `-- <Implementation name n>

However, when *there is only one implementation* for a TASTE function, the implem
folder is omitted. E.g: we have a QGenC function named MyQGenFunc, then the tree
for that function would be:

    TP
    |-- Makefile
    `-- work
        `-- MyQgenFunc
            `-- QGenC   # NOTE: This is NOT a soft-link
                `-- src
                    |-- # Filled with autogenerated files and
                    `-- # Simulink models edited by the user.

"""
